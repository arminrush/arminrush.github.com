---
title: linux单机性能测量
layout: post
category: linux
splitor: <!--more-->
---

往往我们会面临这样的一个问题，我们的主机现在的性能情况如何，是否需要增加主机？对于这样的疑问，不能光拼感觉去推测，而是应该基于测量，掌握服务器资源的使用情况。

我们可以从三个方面入手：
 
 * 平均负载
 * CPU
 * IO

<!--more-->

## 平均负载

### 什么是系统平均负载

系统平均负载为在特定时间内运行队列中可以运行的进程数。

等待的进程有:
 * 等待CPU执行
 * 等待磁盘I/O完成的进程

### 使用uptime/top查看平均负载


```
$ uptime
 15:32:18 up 248 days,  5:45,  2 users,  load average: 0.09, 0.04, 0.01
```

输出信息解读：
 
 * 当前时间 15:32:18
 * 系统已经运行的时间 248天 5：45
 * 当前在线用户 2 user
 * 平均负载：0.09, 0.04, 0.01，最近1分钟、5分钟、15分钟系统的负载


```
$ cat /proc/loadavg
0.00 0.01 0.00 1/355 3043
```

输出信息解读

 * 平均负载：0.09, 0.04, 0.01，最近1分钟、5分钟、15分钟系统的负载
 * 正在运行进程数 1  总仅陈述 355
 * 最后运行的进程ID 3043

平均负载数值越大，说明负载越高。

**平均负载多少才算是高负载**

既然负载指的是进程的运行队列，那么我们得得到这样的结论，有多少核心即为有多少负荷。 在多核处理中，你的系统均值不应该高于处理器核心的总数量。对于单处理器单核满负载的情况下为1.00，两个处理器4核满载为8.00.

通过以下命令可以查看逻辑处理器的数量

```
cat /proc/cpuinfo |grep "processor"|wc -l
```

## 查看CPU和IO使用情况

### top


```
$ top
top - 21:19:11 up 250 days, 11:32,  1 user,  load average: 0.96, 0.81, 0.40
Tasks: 175 total,   1 running, 174 sleeping,   0 stopped,   0 zombie
Cpu(s):  2.6%us,  0.2%sy,  0.0%ni, 97.1%id,  0.0%wa,  0.0%hi,  0.1%si,  0.0%st
Mem:   8061728k total,  7933456k used,   128272k free,   143908k buffers
Swap:  8208376k total,   113172k used,  8095204k free,  2673604k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
  444 appadmin  20   0 8601m 4.5g  12m S 11.0 58.1 400:03.35 java
 1611 apache    20   0  174m 3728 1508 S  0.3  0.0   0:01.89 httpd
 2130 root      20   0  532m  13m 2636 S  0.3  0.2 150:35.74 salt-minion
    1 root      20   0 19224  976  788 S  0.0  0.0   0:03.87 init
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.34 kthreadd
    3 root      RT   0     0    0    0 S  0.0  0.0   0:13.67 migration/0
    4 root      20   0     0    0    0 S  0.0  0.0   2:21.02 ksoftirqd/0
```

 * 第一行 输出内容同uptime
 * 第二行 为 进程汇总信息 175个进程 正在运行1个 睡眠174个 停止0个 僵尸0个
 * 第三行 CPU 信息
   * 用户空间占用CPU百分比 2.6% us
   * 系统空间占用CPU百分比 0.2% sy
   * 用户进程空间内改变过优先级的进程占用CPU百分比 0.0%ni
   * 空闲CPU百分比 97.1%id
   * 等待输入输出的CPU时间百分比 0.0%wa
 * 第五行是 内存使用情况
 * 第六行是 交互区使用情况
 * 下面是进程情况
   * %CPU 为 CPU的占用百分比
   * TIME+ 进程使用的CPU时间总计，单位1/100秒. TIME 为秒
   * %MEM 进程使用的物理内存百分比
   * S 进程状态。 D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程


也可以通过ps命令来查看进程的状态和使用时间


### vmstat

两秒采样一次，输出如下

```
$ vmstat 2
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0 113172 128740 143936 2673228    0    0     0     2    0    0  1  0 99  0  0
 0  0 113172 128608 143936 2673232    0    0     0     0 1892 1216  9  1 91  0  0
 0  0 113172 128608 143936 2673232    0    0     0    18 1636 1255  7  1 92  0  0
 1  0 113172 128484 143936 2673236    0    0     0     6 1727 1412  6  1 94  0  0
 1  0 113172 128360 143936 2673236    0    0     0     0 1874 1335  8  1 91  0  0
 0  0 113172 128360 143936 2673256    0    0     0    68 1883 1482  9  1 90  0  0
 0  0 113172 128360 143936 2673260    0    0     0     0 1808 1197  9  1 90  0  0

```

 * r 表示运行队列的数量
 * b 表示阻塞的进程数量
 * swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了
 * free  空闲的物理内存的大小
 * buff  Linux/Unix系统缓存
 * cache 
 * si 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了
 * so 每秒虚拟内存写入磁盘的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了
 * bi  块设备每秒接收的块数量
 * bo 块设备每秒发送的块数量
 * in 每秒CPU的中断次数，包括时间中断
 * cs 每秒上下文切换次数
 * us 用户CPU时间
 * sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。
 * id  空闲 CPU时间
 * wt 等待IO CPU时间


### sar

```
$ sar

00时00分01秒     CPU     %user     %nice   %system   %iowait    %steal     %idle
00时10分01秒     all      0.19      0.00      0.08      0.00      0.00     99.73
00时20分01秒     all      0.08      0.00      0.06      0.00      0.00     99.85

```
 * CPU：all 表示统计信息为所有 CPU 的平均值。
 * %user：显示在用户级别(application)运行使用 CPU 总时间的百分比。
 * %nice：显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比。
 * %system：在核心级别(kernel)运行所使用 CPU 总时间的百分比。
 * %iowait：显示用于等待I/O操作占用 CPU 总时间的百分比。
 * %steal：利用Xen等操作系统虚拟化技术时，等待其他虚拟CPU计算占用的时间比例
 * %idle：显示 CPU 空闲时间占用 CPU 总时间的百分比。

在多核的主机上，有时需要查看各个CPU的情况，使用-P参数

CPU过高：
 
 * 程序失控，需要消耗过多的CPU。可以通过使用top -H -p pid还可以找到CPU负载最高的线程

IO过高原因：

 * IO请求过多
 * 发生页面交换导致频繁访问磁盘

解决方法：

 * 增加内存其实可以减低IO负载，因为 空闲的内存就会拥有缓存。

